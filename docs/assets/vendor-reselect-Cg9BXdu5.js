function T(e,n=`expected a function, instead received ${typeof e}`){if(typeof e!="function")throw new TypeError(n)}function k(e,n=`expected an object, instead received ${typeof e}`){if(typeof e!="object")throw new TypeError(n)}function z(e,n="expected all items to be functions, instead received the following types: "){if(!e.every(o=>typeof o=="function")){const o=e.map(s=>typeof s=="function"?`function ${s.name||"unnamed"}()`:typeof s).join(", ");throw new TypeError(`${n}[${o}]`)}}var g=e=>Array.isArray(e)?e:[e];function N(e){const n=Array.isArray(e[0])?e[0]:e;return z(n,"createSelector expects all input-selectors to be functions, but received the following types: "),n}function E(e,n){const o=[],{length:s}=e;for(let u=0;u<s;u++)o.push(e[u].apply(null,n));return o}var x=class{constructor(e){this.value=e}deref(){return this.value}},I=typeof WeakRef<"u"?WeakRef:x,O=0,b=1;function v(){return{s:O,v:void 0,o:null,p:null}}function w(e,n={}){let o=v();const{resultEqualityCheck:s}=n;let u,r=0;function i(){let t=o;const{length:y}=arguments;for(let p=0,m=y;p<m;p++){const f=arguments[p];if(typeof f=="function"||typeof f=="object"&&f!==null){let l=t.o;l===null&&(t.o=l=new WeakMap);const d=l.get(f);d===void 0?(t=v(),l.set(f,t)):t=d}else{let l=t.p;l===null&&(t.p=l=new Map);const d=l.get(f);d===void 0?(t=v(),l.set(f,t)):t=d}}const a=t;let c;if(t.s===b)c=t.v;else if(c=e.apply(null,arguments),r++,s){const p=u?.deref?.()??u;p!=null&&s(p,c)&&(c=p,r!==0&&r--),u=typeof c=="object"&&c!==null||typeof c=="function"?new I(c):c}return a.s=b,a.v=c,c}return i.clearCache=()=>{o=v(),i.resetResultsCount()},i.resultsCount=()=>r,i.resetResultsCount=()=>{r=0},i}function $(e,...n){const o=typeof e=="function"?{memoize:e,memoizeOptions:n}:e,s=(...u)=>{let r=0,i=0,t,y={},a=u.pop();typeof a=="object"&&(y=a,a=u.pop()),T(a,`createSelector expects an output function after the inputs, but received: [${typeof a}]`);const c={...o,...y},{memoize:p,memoizeOptions:m=[],argsMemoize:f=w,argsMemoizeOptions:l=[]}=c,d=g(m),C=g(l),h=N(u),R=p(function(){return r++,a.apply(null,arguments)},...d),j=f(function(){i++;const S=E(h,arguments);return t=R.apply(null,S),t},...C);return Object.assign(j,{resultFunc:a,memoizedResultFunc:R,dependencies:h,dependencyRecomputations:()=>i,resetDependencyRecomputations:()=>{i=0},lastResult:()=>t,recomputations:()=>r,resetRecomputations:()=>{r=0},memoize:p,argsMemoize:f})};return Object.assign(s,{withTypes:()=>s}),s}var W=$(w),A=Object.assign((e,n=W)=>{k(e,`createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof e}`);const o=Object.keys(e),s=o.map(r=>e[r]);return n(s,(...r)=>r.reduce((i,t,y)=>(i[o[y]]=t,i),{}))},{withTypes:()=>A});export{W as c};
